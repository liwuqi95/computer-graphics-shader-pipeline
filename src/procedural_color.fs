// Set the pixel color to an interesting procedural color generated by mixing
// and filtering Perlin noise of different frequencies.
//
// Uniforms:
uniform mat4 view;
uniform mat4 proj;
uniform float animation_seconds;
uniform bool is_moon;
// Inputs:
in vec3 sphere_fs_in;
in vec3 normal_fs_in;
in vec4 pos_fs_in; 
in vec4 view_pos_fs_in; 
// Outputs:
out vec3 color;

float turb(vec3 position, float size){
    float random = 0;
    float scale = 1;
    while(scale > size){
        position = position / scale;
        random = random + perlin_noise(position)*scale;
        scale = scale/2;
    }
    return random;
}
//http://physbam.stanford.edu/cs448x/old/Procedural_Noise(2f)Perlin_Noise.html

// expects: blinn_phong, perlin_noise
void main()
{
  /////////////////////////////////////////////////////////////////////////////

  float theta = 0.5*M_PI*animation_seconds;
  mat3 rotation = mat3(cos(theta),0,sin(theta),0,1,0,-sin(theta),0,cos(theta));

  vec3 ka = is_moon ? vec3(0.02) : vec3(0.013,0.013,0.031);
  vec3 kd = is_moon ? vec3(0.2) : vec3(0.19,0.24,0.75);
  vec3 ks = is_moon ? vec3(0.8) : vec3(0.8);

  vec3 n = normalize(normal_fs_in);
  vec3 v = -normalize((view_pos_fs_in/view_pos_fs_in.w).xyz);
  vec3 l = rotation*normalize(vec3(3,2,0));

  float random = sqrt(sin((sphere_fs_in.y+3.0*turb(2*sphere_fs_in, 0.5))*M_PI) + 1) * 0.7071;

  if (is_moon) kd = kd + vec3(0.2 * sqrt(random), 0.2 * random, 0.2* sqrt(random));
    else kd = kd + vec3(0.2 * sqrt(random), 0.4 * random, 0.2* sqrt(random));

  color = blinn_phong(ka, kd, ks, 1000, n, v, l);

  /////////////////////////////////////////////////////////////////////////////
}
